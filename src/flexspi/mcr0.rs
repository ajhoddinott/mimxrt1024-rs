#[doc = "Register `MCR0` reader"]
pub struct R(crate::R<MCR0_SPEC>);
impl core::ops::Deref for R {
    type Target = crate::R<MCR0_SPEC>;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl From<crate::R<MCR0_SPEC>> for R {
    #[inline(always)]
    fn from(reader: crate::R<MCR0_SPEC>) -> Self {
        R(reader)
    }
}
#[doc = "Register `MCR0` writer"]
pub struct W(crate::W<MCR0_SPEC>);
impl core::ops::Deref for W {
    type Target = crate::W<MCR0_SPEC>;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl core::ops::DerefMut for W {
    #[inline(always)]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
impl From<crate::W<MCR0_SPEC>> for W {
    #[inline(always)]
    fn from(writer: crate::W<MCR0_SPEC>) -> Self {
        W(writer)
    }
}
#[doc = "Field `SWRESET` reader - Software Reset"]
pub type SWRESET_R = crate::BitReader<bool>;
#[doc = "Field `SWRESET` writer - Software Reset"]
pub type SWRESET_W<'a, const O: u8> = crate::BitWriter<'a, u32, MCR0_SPEC, bool, O>;
#[doc = "Field `MDIS` reader - Module Disable"]
pub type MDIS_R = crate::BitReader<bool>;
#[doc = "Field `MDIS` writer - Module Disable"]
pub type MDIS_W<'a, const O: u8> = crate::BitWriter<'a, u32, MCR0_SPEC, bool, O>;
#[doc = "Field `RXCLKSRC` reader - Sample Clock source selection for Flash Reading"]
pub type RXCLKSRC_R = crate::FieldReader<u8, RXCLKSRC_A>;
#[doc = "Sample Clock source selection for Flash Reading\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum RXCLKSRC_A {
    #[doc = "0: Dummy Read strobe generated by FlexSPI Controller and loopback internally."]
    RXCLKSRC_0 = 0,
    #[doc = "1: Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad."]
    RXCLKSRC_1 = 1,
    #[doc = "3: Flash provided Read strobe and input from DQS pad"]
    RXCLKSRC_3 = 3,
}
impl From<RXCLKSRC_A> for u8 {
    #[inline(always)]
    fn from(variant: RXCLKSRC_A) -> Self {
        variant as _
    }
}
impl RXCLKSRC_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub fn variant(&self) -> Option<RXCLKSRC_A> {
        match self.bits {
            0 => Some(RXCLKSRC_A::RXCLKSRC_0),
            1 => Some(RXCLKSRC_A::RXCLKSRC_1),
            3 => Some(RXCLKSRC_A::RXCLKSRC_3),
            _ => None,
        }
    }
    #[doc = "Checks if the value of the field is `RXCLKSRC_0`"]
    #[inline(always)]
    pub fn is_rxclksrc_0(&self) -> bool {
        *self == RXCLKSRC_A::RXCLKSRC_0
    }
    #[doc = "Checks if the value of the field is `RXCLKSRC_1`"]
    #[inline(always)]
    pub fn is_rxclksrc_1(&self) -> bool {
        *self == RXCLKSRC_A::RXCLKSRC_1
    }
    #[doc = "Checks if the value of the field is `RXCLKSRC_3`"]
    #[inline(always)]
    pub fn is_rxclksrc_3(&self) -> bool {
        *self == RXCLKSRC_A::RXCLKSRC_3
    }
}
#[doc = "Field `RXCLKSRC` writer - Sample Clock source selection for Flash Reading"]
pub type RXCLKSRC_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MCR0_SPEC, u8, RXCLKSRC_A, 2, O>;
impl<'a, const O: u8> RXCLKSRC_W<'a, O> {
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback internally."]
    #[inline(always)]
    pub fn rxclksrc_0(self) -> &'a mut W {
        self.variant(RXCLKSRC_A::RXCLKSRC_0)
    }
    #[doc = "Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad."]
    #[inline(always)]
    pub fn rxclksrc_1(self) -> &'a mut W {
        self.variant(RXCLKSRC_A::RXCLKSRC_1)
    }
    #[doc = "Flash provided Read strobe and input from DQS pad"]
    #[inline(always)]
    pub fn rxclksrc_3(self) -> &'a mut W {
        self.variant(RXCLKSRC_A::RXCLKSRC_3)
    }
}
#[doc = "Field `ARDFEN` reader - Enable AHB bus Read Access to IP RX FIFO."]
pub type ARDFEN_R = crate::BitReader<ARDFEN_A>;
#[doc = "Enable AHB bus Read Access to IP RX FIFO.\n\nValue on reset: 1"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ARDFEN_A {
    #[doc = "0: IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response."]
    ARDFEN_0 = 0,
    #[doc = "1: IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response."]
    ARDFEN_1 = 1,
}
impl From<ARDFEN_A> for bool {
    #[inline(always)]
    fn from(variant: ARDFEN_A) -> Self {
        variant as u8 != 0
    }
}
impl ARDFEN_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub fn variant(&self) -> ARDFEN_A {
        match self.bits {
            false => ARDFEN_A::ARDFEN_0,
            true => ARDFEN_A::ARDFEN_1,
        }
    }
    #[doc = "Checks if the value of the field is `ARDFEN_0`"]
    #[inline(always)]
    pub fn is_ardfen_0(&self) -> bool {
        *self == ARDFEN_A::ARDFEN_0
    }
    #[doc = "Checks if the value of the field is `ARDFEN_1`"]
    #[inline(always)]
    pub fn is_ardfen_1(&self) -> bool {
        *self == ARDFEN_A::ARDFEN_1
    }
}
#[doc = "Field `ARDFEN` writer - Enable AHB bus Read Access to IP RX FIFO."]
pub type ARDFEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, MCR0_SPEC, ARDFEN_A, O>;
impl<'a, const O: u8> ARDFEN_W<'a, O> {
    #[doc = "IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response."]
    #[inline(always)]
    pub fn ardfen_0(self) -> &'a mut W {
        self.variant(ARDFEN_A::ARDFEN_0)
    }
    #[doc = "IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response."]
    #[inline(always)]
    pub fn ardfen_1(self) -> &'a mut W {
        self.variant(ARDFEN_A::ARDFEN_1)
    }
}
#[doc = "Field `ATDFEN` reader - Enable AHB bus Write Access to IP TX FIFO."]
pub type ATDFEN_R = crate::BitReader<ATDFEN_A>;
#[doc = "Enable AHB bus Write Access to IP TX FIFO.\n\nValue on reset: 1"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ATDFEN_A {
    #[doc = "0: IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response."]
    ATDFEN_0 = 0,
    #[doc = "1: IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response."]
    ATDFEN_1 = 1,
}
impl From<ATDFEN_A> for bool {
    #[inline(always)]
    fn from(variant: ATDFEN_A) -> Self {
        variant as u8 != 0
    }
}
impl ATDFEN_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub fn variant(&self) -> ATDFEN_A {
        match self.bits {
            false => ATDFEN_A::ATDFEN_0,
            true => ATDFEN_A::ATDFEN_1,
        }
    }
    #[doc = "Checks if the value of the field is `ATDFEN_0`"]
    #[inline(always)]
    pub fn is_atdfen_0(&self) -> bool {
        *self == ATDFEN_A::ATDFEN_0
    }
    #[doc = "Checks if the value of the field is `ATDFEN_1`"]
    #[inline(always)]
    pub fn is_atdfen_1(&self) -> bool {
        *self == ATDFEN_A::ATDFEN_1
    }
}
#[doc = "Field `ATDFEN` writer - Enable AHB bus Write Access to IP TX FIFO."]
pub type ATDFEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, MCR0_SPEC, ATDFEN_A, O>;
impl<'a, const O: u8> ATDFEN_W<'a, O> {
    #[doc = "IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response."]
    #[inline(always)]
    pub fn atdfen_0(self) -> &'a mut W {
        self.variant(ATDFEN_A::ATDFEN_0)
    }
    #[doc = "IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response."]
    #[inline(always)]
    pub fn atdfen_1(self) -> &'a mut W {
        self.variant(ATDFEN_A::ATDFEN_1)
    }
}
#[doc = "Field `SERCLKDIV` reader - The serial root clock could be divided inside FlexSPI . See Clocks section for more details on clocking."]
pub type SERCLKDIV_R = crate::FieldReader<u8, SERCLKDIV_A>;
#[doc = "The serial root clock could be divided inside FlexSPI . See Clocks section for more details on clocking.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum SERCLKDIV_A {
    #[doc = "0: Divided by 1"]
    SERCLKDIV_0 = 0,
    #[doc = "1: Divided by 2"]
    SERCLKDIV_1 = 1,
    #[doc = "2: Divided by 3"]
    SERCLKDIV_2 = 2,
    #[doc = "3: Divided by 4"]
    SERCLKDIV_3 = 3,
    #[doc = "4: Divided by 5"]
    SERCLKDIV_4 = 4,
    #[doc = "5: Divided by 6"]
    SERCLKDIV_5 = 5,
    #[doc = "6: Divided by 7"]
    SERCLKDIV_6 = 6,
    #[doc = "7: Divided by 8"]
    SERCLKDIV_7 = 7,
}
impl From<SERCLKDIV_A> for u8 {
    #[inline(always)]
    fn from(variant: SERCLKDIV_A) -> Self {
        variant as _
    }
}
impl SERCLKDIV_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub fn variant(&self) -> SERCLKDIV_A {
        match self.bits {
            0 => SERCLKDIV_A::SERCLKDIV_0,
            1 => SERCLKDIV_A::SERCLKDIV_1,
            2 => SERCLKDIV_A::SERCLKDIV_2,
            3 => SERCLKDIV_A::SERCLKDIV_3,
            4 => SERCLKDIV_A::SERCLKDIV_4,
            5 => SERCLKDIV_A::SERCLKDIV_5,
            6 => SERCLKDIV_A::SERCLKDIV_6,
            7 => SERCLKDIV_A::SERCLKDIV_7,
            _ => unreachable!(),
        }
    }
    #[doc = "Checks if the value of the field is `SERCLKDIV_0`"]
    #[inline(always)]
    pub fn is_serclkdiv_0(&self) -> bool {
        *self == SERCLKDIV_A::SERCLKDIV_0
    }
    #[doc = "Checks if the value of the field is `SERCLKDIV_1`"]
    #[inline(always)]
    pub fn is_serclkdiv_1(&self) -> bool {
        *self == SERCLKDIV_A::SERCLKDIV_1
    }
    #[doc = "Checks if the value of the field is `SERCLKDIV_2`"]
    #[inline(always)]
    pub fn is_serclkdiv_2(&self) -> bool {
        *self == SERCLKDIV_A::SERCLKDIV_2
    }
    #[doc = "Checks if the value of the field is `SERCLKDIV_3`"]
    #[inline(always)]
    pub fn is_serclkdiv_3(&self) -> bool {
        *self == SERCLKDIV_A::SERCLKDIV_3
    }
    #[doc = "Checks if the value of the field is `SERCLKDIV_4`"]
    #[inline(always)]
    pub fn is_serclkdiv_4(&self) -> bool {
        *self == SERCLKDIV_A::SERCLKDIV_4
    }
    #[doc = "Checks if the value of the field is `SERCLKDIV_5`"]
    #[inline(always)]
    pub fn is_serclkdiv_5(&self) -> bool {
        *self == SERCLKDIV_A::SERCLKDIV_5
    }
    #[doc = "Checks if the value of the field is `SERCLKDIV_6`"]
    #[inline(always)]
    pub fn is_serclkdiv_6(&self) -> bool {
        *self == SERCLKDIV_A::SERCLKDIV_6
    }
    #[doc = "Checks if the value of the field is `SERCLKDIV_7`"]
    #[inline(always)]
    pub fn is_serclkdiv_7(&self) -> bool {
        *self == SERCLKDIV_A::SERCLKDIV_7
    }
}
#[doc = "Field `SERCLKDIV` writer - The serial root clock could be divided inside FlexSPI . See Clocks section for more details on clocking."]
pub type SERCLKDIV_W<'a, const O: u8> =
    crate::FieldWriterSafe<'a, u32, MCR0_SPEC, u8, SERCLKDIV_A, 3, O>;
impl<'a, const O: u8> SERCLKDIV_W<'a, O> {
    #[doc = "Divided by 1"]
    #[inline(always)]
    pub fn serclkdiv_0(self) -> &'a mut W {
        self.variant(SERCLKDIV_A::SERCLKDIV_0)
    }
    #[doc = "Divided by 2"]
    #[inline(always)]
    pub fn serclkdiv_1(self) -> &'a mut W {
        self.variant(SERCLKDIV_A::SERCLKDIV_1)
    }
    #[doc = "Divided by 3"]
    #[inline(always)]
    pub fn serclkdiv_2(self) -> &'a mut W {
        self.variant(SERCLKDIV_A::SERCLKDIV_2)
    }
    #[doc = "Divided by 4"]
    #[inline(always)]
    pub fn serclkdiv_3(self) -> &'a mut W {
        self.variant(SERCLKDIV_A::SERCLKDIV_3)
    }
    #[doc = "Divided by 5"]
    #[inline(always)]
    pub fn serclkdiv_4(self) -> &'a mut W {
        self.variant(SERCLKDIV_A::SERCLKDIV_4)
    }
    #[doc = "Divided by 6"]
    #[inline(always)]
    pub fn serclkdiv_5(self) -> &'a mut W {
        self.variant(SERCLKDIV_A::SERCLKDIV_5)
    }
    #[doc = "Divided by 7"]
    #[inline(always)]
    pub fn serclkdiv_6(self) -> &'a mut W {
        self.variant(SERCLKDIV_A::SERCLKDIV_6)
    }
    #[doc = "Divided by 8"]
    #[inline(always)]
    pub fn serclkdiv_7(self) -> &'a mut W {
        self.variant(SERCLKDIV_A::SERCLKDIV_7)
    }
}
#[doc = "Field `HSEN` reader - Half Speed Serial Flash access Enable."]
pub type HSEN_R = crate::BitReader<HSEN_A>;
#[doc = "Half Speed Serial Flash access Enable.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum HSEN_A {
    #[doc = "0: Disable divide by 2 of serial flash clock for half speed commands."]
    HSEN_0 = 0,
    #[doc = "1: Enable divide by 2 of serial flash clock for half speed commands."]
    HSEN_1 = 1,
}
impl From<HSEN_A> for bool {
    #[inline(always)]
    fn from(variant: HSEN_A) -> Self {
        variant as u8 != 0
    }
}
impl HSEN_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub fn variant(&self) -> HSEN_A {
        match self.bits {
            false => HSEN_A::HSEN_0,
            true => HSEN_A::HSEN_1,
        }
    }
    #[doc = "Checks if the value of the field is `HSEN_0`"]
    #[inline(always)]
    pub fn is_hsen_0(&self) -> bool {
        *self == HSEN_A::HSEN_0
    }
    #[doc = "Checks if the value of the field is `HSEN_1`"]
    #[inline(always)]
    pub fn is_hsen_1(&self) -> bool {
        *self == HSEN_A::HSEN_1
    }
}
#[doc = "Field `HSEN` writer - Half Speed Serial Flash access Enable."]
pub type HSEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, MCR0_SPEC, HSEN_A, O>;
impl<'a, const O: u8> HSEN_W<'a, O> {
    #[doc = "Disable divide by 2 of serial flash clock for half speed commands."]
    #[inline(always)]
    pub fn hsen_0(self) -> &'a mut W {
        self.variant(HSEN_A::HSEN_0)
    }
    #[doc = "Enable divide by 2 of serial flash clock for half speed commands."]
    #[inline(always)]
    pub fn hsen_1(self) -> &'a mut W {
        self.variant(HSEN_A::HSEN_1)
    }
}
#[doc = "Field `DOZEEN` reader - Doze mode enable bit"]
pub type DOZEEN_R = crate::BitReader<DOZEEN_A>;
#[doc = "Doze mode enable bit\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum DOZEEN_A {
    #[doc = "0: Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system."]
    DOZEEN_0 = 0,
    #[doc = "1: Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system."]
    DOZEEN_1 = 1,
}
impl From<DOZEEN_A> for bool {
    #[inline(always)]
    fn from(variant: DOZEEN_A) -> Self {
        variant as u8 != 0
    }
}
impl DOZEEN_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub fn variant(&self) -> DOZEEN_A {
        match self.bits {
            false => DOZEEN_A::DOZEEN_0,
            true => DOZEEN_A::DOZEEN_1,
        }
    }
    #[doc = "Checks if the value of the field is `DOZEEN_0`"]
    #[inline(always)]
    pub fn is_dozeen_0(&self) -> bool {
        *self == DOZEEN_A::DOZEEN_0
    }
    #[doc = "Checks if the value of the field is `DOZEEN_1`"]
    #[inline(always)]
    pub fn is_dozeen_1(&self) -> bool {
        *self == DOZEEN_A::DOZEEN_1
    }
}
#[doc = "Field `DOZEEN` writer - Doze mode enable bit"]
pub type DOZEEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, MCR0_SPEC, DOZEEN_A, O>;
impl<'a, const O: u8> DOZEEN_W<'a, O> {
    #[doc = "Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system."]
    #[inline(always)]
    pub fn dozeen_0(self) -> &'a mut W {
        self.variant(DOZEEN_A::DOZEEN_0)
    }
    #[doc = "Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system."]
    #[inline(always)]
    pub fn dozeen_1(self) -> &'a mut W {
        self.variant(DOZEEN_A::DOZEEN_1)
    }
}
#[doc = "Field `COMBINATIONEN` reader - This bit is to support Flash Octal mode access by combining Port A and B Data pins (A_DATA\\[3:0\\]
and B_DATA\\[3:0\\]), when Port A and Port B are of 4 bit data width."]
pub type COMBINATIONEN_R = crate::BitReader<COMBINATIONEN_A>;
#[doc = "This bit is to support Flash Octal mode access by combining Port A and B Data pins (A_DATA\\[3:0\\]
and B_DATA\\[3:0\\]), when Port A and Port B are of 4 bit data width.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum COMBINATIONEN_A {
    #[doc = "0: Disable."]
    DISABLE = 0,
    #[doc = "1: Enable."]
    ENABLE = 1,
}
impl From<COMBINATIONEN_A> for bool {
    #[inline(always)]
    fn from(variant: COMBINATIONEN_A) -> Self {
        variant as u8 != 0
    }
}
impl COMBINATIONEN_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub fn variant(&self) -> COMBINATIONEN_A {
        match self.bits {
            false => COMBINATIONEN_A::DISABLE,
            true => COMBINATIONEN_A::ENABLE,
        }
    }
    #[doc = "Checks if the value of the field is `DISABLE`"]
    #[inline(always)]
    pub fn is_disable(&self) -> bool {
        *self == COMBINATIONEN_A::DISABLE
    }
    #[doc = "Checks if the value of the field is `ENABLE`"]
    #[inline(always)]
    pub fn is_enable(&self) -> bool {
        *self == COMBINATIONEN_A::ENABLE
    }
}
#[doc = "Field `COMBINATIONEN` writer - This bit is to support Flash Octal mode access by combining Port A and B Data pins (A_DATA\\[3:0\\]
and B_DATA\\[3:0\\]), when Port A and Port B are of 4 bit data width."]
pub type COMBINATIONEN_W<'a, const O: u8> =
    crate::BitWriter<'a, u32, MCR0_SPEC, COMBINATIONEN_A, O>;
impl<'a, const O: u8> COMBINATIONEN_W<'a, O> {
    #[doc = "Disable."]
    #[inline(always)]
    pub fn disable(self) -> &'a mut W {
        self.variant(COMBINATIONEN_A::DISABLE)
    }
    #[doc = "Enable."]
    #[inline(always)]
    pub fn enable(self) -> &'a mut W {
        self.variant(COMBINATIONEN_A::ENABLE)
    }
}
#[doc = "Field `SCKFREERUNEN` reader - This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\\[RXCLKSRC\\]=2)."]
pub type SCKFREERUNEN_R = crate::BitReader<SCKFREERUNEN_A>;
#[doc = "This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\\[RXCLKSRC\\]=2).\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum SCKFREERUNEN_A {
    #[doc = "0: Disable."]
    DISABLE = 0,
    #[doc = "1: Enable."]
    ENABLE = 1,
}
impl From<SCKFREERUNEN_A> for bool {
    #[inline(always)]
    fn from(variant: SCKFREERUNEN_A) -> Self {
        variant as u8 != 0
    }
}
impl SCKFREERUNEN_R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub fn variant(&self) -> SCKFREERUNEN_A {
        match self.bits {
            false => SCKFREERUNEN_A::DISABLE,
            true => SCKFREERUNEN_A::ENABLE,
        }
    }
    #[doc = "Checks if the value of the field is `DISABLE`"]
    #[inline(always)]
    pub fn is_disable(&self) -> bool {
        *self == SCKFREERUNEN_A::DISABLE
    }
    #[doc = "Checks if the value of the field is `ENABLE`"]
    #[inline(always)]
    pub fn is_enable(&self) -> bool {
        *self == SCKFREERUNEN_A::ENABLE
    }
}
#[doc = "Field `SCKFREERUNEN` writer - This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\\[RXCLKSRC\\]=2)."]
pub type SCKFREERUNEN_W<'a, const O: u8> = crate::BitWriter<'a, u32, MCR0_SPEC, SCKFREERUNEN_A, O>;
impl<'a, const O: u8> SCKFREERUNEN_W<'a, O> {
    #[doc = "Disable."]
    #[inline(always)]
    pub fn disable(self) -> &'a mut W {
        self.variant(SCKFREERUNEN_A::DISABLE)
    }
    #[doc = "Enable."]
    #[inline(always)]
    pub fn enable(self) -> &'a mut W {
        self.variant(SCKFREERUNEN_A::ENABLE)
    }
}
#[doc = "Field `IPGRANTWAIT` reader - Time out wait cycle for IP command grant."]
pub type IPGRANTWAIT_R = crate::FieldReader<u8, u8>;
#[doc = "Field `IPGRANTWAIT` writer - Time out wait cycle for IP command grant."]
pub type IPGRANTWAIT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MCR0_SPEC, u8, u8, 8, O>;
#[doc = "Field `AHBGRANTWAIT` reader - Timeout wait cycle for AHB command grant."]
pub type AHBGRANTWAIT_R = crate::FieldReader<u8, u8>;
#[doc = "Field `AHBGRANTWAIT` writer - Timeout wait cycle for AHB command grant."]
pub type AHBGRANTWAIT_W<'a, const O: u8> = crate::FieldWriter<'a, u32, MCR0_SPEC, u8, u8, 8, O>;
impl R {
    #[doc = "Bit 0 - Software Reset"]
    #[inline(always)]
    pub fn swreset(&self) -> SWRESET_R {
        SWRESET_R::new((self.bits & 1) != 0)
    }
    #[doc = "Bit 1 - Module Disable"]
    #[inline(always)]
    pub fn mdis(&self) -> MDIS_R {
        MDIS_R::new(((self.bits >> 1) & 1) != 0)
    }
    #[doc = "Bits 4:5 - Sample Clock source selection for Flash Reading"]
    #[inline(always)]
    pub fn rxclksrc(&self) -> RXCLKSRC_R {
        RXCLKSRC_R::new(((self.bits >> 4) & 3) as u8)
    }
    #[doc = "Bit 6 - Enable AHB bus Read Access to IP RX FIFO."]
    #[inline(always)]
    pub fn ardfen(&self) -> ARDFEN_R {
        ARDFEN_R::new(((self.bits >> 6) & 1) != 0)
    }
    #[doc = "Bit 7 - Enable AHB bus Write Access to IP TX FIFO."]
    #[inline(always)]
    pub fn atdfen(&self) -> ATDFEN_R {
        ATDFEN_R::new(((self.bits >> 7) & 1) != 0)
    }
    #[doc = "Bits 8:10 - The serial root clock could be divided inside FlexSPI . See Clocks section for more details on clocking."]
    #[inline(always)]
    pub fn serclkdiv(&self) -> SERCLKDIV_R {
        SERCLKDIV_R::new(((self.bits >> 8) & 7) as u8)
    }
    #[doc = "Bit 11 - Half Speed Serial Flash access Enable."]
    #[inline(always)]
    pub fn hsen(&self) -> HSEN_R {
        HSEN_R::new(((self.bits >> 11) & 1) != 0)
    }
    #[doc = "Bit 12 - Doze mode enable bit"]
    #[inline(always)]
    pub fn dozeen(&self) -> DOZEEN_R {
        DOZEEN_R::new(((self.bits >> 12) & 1) != 0)
    }
    #[doc = "Bit 13 - This bit is to support Flash Octal mode access by combining Port A and B Data pins (A_DATA\\[3:0\\]
and B_DATA\\[3:0\\]), when Port A and Port B are of 4 bit data width."]
    #[inline(always)]
    pub fn combinationen(&self) -> COMBINATIONEN_R {
        COMBINATIONEN_R::new(((self.bits >> 13) & 1) != 0)
    }
    #[doc = "Bit 14 - This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\\[RXCLKSRC\\]=2)."]
    #[inline(always)]
    pub fn sckfreerunen(&self) -> SCKFREERUNEN_R {
        SCKFREERUNEN_R::new(((self.bits >> 14) & 1) != 0)
    }
    #[doc = "Bits 16:23 - Time out wait cycle for IP command grant."]
    #[inline(always)]
    pub fn ipgrantwait(&self) -> IPGRANTWAIT_R {
        IPGRANTWAIT_R::new(((self.bits >> 16) & 0xff) as u8)
    }
    #[doc = "Bits 24:31 - Timeout wait cycle for AHB command grant."]
    #[inline(always)]
    pub fn ahbgrantwait(&self) -> AHBGRANTWAIT_R {
        AHBGRANTWAIT_R::new(((self.bits >> 24) & 0xff) as u8)
    }
}
impl W {
    #[doc = "Bit 0 - Software Reset"]
    #[inline(always)]
    #[must_use]
    pub fn swreset(&mut self) -> SWRESET_W<0> {
        SWRESET_W::new(self)
    }
    #[doc = "Bit 1 - Module Disable"]
    #[inline(always)]
    #[must_use]
    pub fn mdis(&mut self) -> MDIS_W<1> {
        MDIS_W::new(self)
    }
    #[doc = "Bits 4:5 - Sample Clock source selection for Flash Reading"]
    #[inline(always)]
    #[must_use]
    pub fn rxclksrc(&mut self) -> RXCLKSRC_W<4> {
        RXCLKSRC_W::new(self)
    }
    #[doc = "Bit 6 - Enable AHB bus Read Access to IP RX FIFO."]
    #[inline(always)]
    #[must_use]
    pub fn ardfen(&mut self) -> ARDFEN_W<6> {
        ARDFEN_W::new(self)
    }
    #[doc = "Bit 7 - Enable AHB bus Write Access to IP TX FIFO."]
    #[inline(always)]
    #[must_use]
    pub fn atdfen(&mut self) -> ATDFEN_W<7> {
        ATDFEN_W::new(self)
    }
    #[doc = "Bits 8:10 - The serial root clock could be divided inside FlexSPI . See Clocks section for more details on clocking."]
    #[inline(always)]
    #[must_use]
    pub fn serclkdiv(&mut self) -> SERCLKDIV_W<8> {
        SERCLKDIV_W::new(self)
    }
    #[doc = "Bit 11 - Half Speed Serial Flash access Enable."]
    #[inline(always)]
    #[must_use]
    pub fn hsen(&mut self) -> HSEN_W<11> {
        HSEN_W::new(self)
    }
    #[doc = "Bit 12 - Doze mode enable bit"]
    #[inline(always)]
    #[must_use]
    pub fn dozeen(&mut self) -> DOZEEN_W<12> {
        DOZEEN_W::new(self)
    }
    #[doc = "Bit 13 - This bit is to support Flash Octal mode access by combining Port A and B Data pins (A_DATA\\[3:0\\]
and B_DATA\\[3:0\\]), when Port A and Port B are of 4 bit data width."]
    #[inline(always)]
    #[must_use]
    pub fn combinationen(&mut self) -> COMBINATIONEN_W<13> {
        COMBINATIONEN_W::new(self)
    }
    #[doc = "Bit 14 - This bit is used to force SCLK output free-running. For FPGA applications, external device may use SCLK as reference clock to its internal PLL. If SCLK free-running is enabled, data sampling with loopback clock from SCLK pad is not supported (MCR0\\[RXCLKSRC\\]=2)."]
    #[inline(always)]
    #[must_use]
    pub fn sckfreerunen(&mut self) -> SCKFREERUNEN_W<14> {
        SCKFREERUNEN_W::new(self)
    }
    #[doc = "Bits 16:23 - Time out wait cycle for IP command grant."]
    #[inline(always)]
    #[must_use]
    pub fn ipgrantwait(&mut self) -> IPGRANTWAIT_W<16> {
        IPGRANTWAIT_W::new(self)
    }
    #[doc = "Bits 24:31 - Timeout wait cycle for AHB command grant."]
    #[inline(always)]
    #[must_use]
    pub fn ahbgrantwait(&mut self) -> AHBGRANTWAIT_W<24> {
        AHBGRANTWAIT_W::new(self)
    }
    #[doc = "Writes raw bits to the register."]
    #[inline(always)]
    pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
        self.0.bits(bits);
        self
    }
}
#[doc = "Module Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcr0](index.html) module"]
pub struct MCR0_SPEC;
impl crate::RegisterSpec for MCR0_SPEC {
    type Ux = u32;
}
#[doc = "`read()` method returns [mcr0::R](R) reader structure"]
impl crate::Readable for MCR0_SPEC {
    type Reader = R;
}
#[doc = "`write(|w| ..)` method takes [mcr0::W](W) writer structure"]
impl crate::Writable for MCR0_SPEC {
    type Writer = W;
    const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
    const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = 0;
}
#[doc = "`reset()` method sets MCR0 to value 0xffff_80c2"]
impl crate::Resettable for MCR0_SPEC {
    const RESET_VALUE: Self::Ux = 0xffff_80c2;
}
